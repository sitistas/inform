<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Constants and Descriptions</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure.html">structure</a></li>
<li><a href="../inbuildn.html">inbuild</a></li>
<li><a href="../inform7n.html">inform7</a></li>
<li><a href="../intern.html">inter</a></li>
<li><a href="../services.html">services</a></li>
<li><a href="../secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn.html">inblorb</a></li>
<li><a href="../indocn.html">indoc</a></li>
<li><a href="../inform6.html">inform6</a></li>
<li><a href="../inpolicyn.html">inpolicy</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions.html">extensions</a></li>
<li><a href="../kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=18> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="../../../inweb/index.html">inweb</a></li>
<li><a href="../../../intest/index.html">intest</a></li>

</ul>
		</nav>
		<main role="main">
		<!-- Weave of 'Constants and Descriptions' generated by Inweb -->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../inform7n.html">Inform7</a></li><li><a href="index.html">values</a></li><li><a href="index.html#4">Chapter 4: The S-Parser</a></li><li><b>Constants and Descriptions</b></li></ul></div>
<p class="purpose">To parse noun phrases in constant contexts, which specify values either explicitly or by describing them more or less vaguely.</p>

<ul class="toc"><li><a href="4-cad.html#SP1">&#167;1. Constant values</a></li><li><a href="4-cad.html#SP8">&#167;8. Adjective lists</a></li><li><a href="4-cad.html#SP18">&#167;18. Descriptions</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. Constant values. </b>As we've seen, not all of the names Inform knows are literals. The following
nonterminal covers constants in general, a wider category.
</p>

<p class="commentary">The word "nothing" needs special treatment later on. Sometimes it means
the dummy value "not an object", and is genuinely a constant value;
but at other times it behaves more like a determiner, as in "if nothing
is on the table". For now, though, we treat it as a noun.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-constant-value&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-literal&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                 </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">nothing</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                     </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Rvalues::new_nothing_object_constant() }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-miscellaneous-proper-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-rulebook-outcome-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">outcome</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-use-option-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">option</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">verb</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;instance-of-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                     </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP1_1" class="named-paragraph-link"><span class="named-paragraph">Compose verb ML</span><span class="named-paragraph-number">1.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">verb</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;instance-of-infinitive-form&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP1_1" class="named-paragraph-link"><span class="named-paragraph">Compose verb ML</span><span class="named-paragraph-number">1.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-rule-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">response</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">(</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;response-letter&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">)</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP1_2" class="named-paragraph-link"><span class="named-paragraph">Compose response ML</span><span class="named-paragraph-number">1.2</span></a></span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP1_1" class="paragraph-anchor"></a><b>&#167;1.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compose verb ML</span><span class="named-paragraph-number">1.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">verb_form</span><span class="plain-syntax"> *</span><span class="identifier-syntax">vf</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">verb_form</span><span class="plain-syntax"> *) (</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">RTVerbs::verb_form_is_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">vf</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::quote_wording</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_NonInstanceVerbForm</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">            </span><span class="string-syntax">"'%1' can't be used as a value of the kind 'verb'. In general, forms "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"such as 'to be' plus a preposition, or auxiliary verbs, are not allowed "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"in this context, because they aren't really different verbs in the way "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"that, say, 'the verb carry' or 'the verb enclose' are."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
<span class="plain-syntax">        ==&gt; { </span><span class="identifier-syntax">fail</span><span class="plain-syntax"> };</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="2-rvl.html#SP2" class="function-link"><span class="function-syntax">Rvalues::from_verb_form</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">vf</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { -, </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cad.html#SP1">&#167;1</a> (twice).</li></ul>
<p class="commentary firstcommentary"><a id="SP1_2" class="paragraph-anchor"></a><b>&#167;1.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compose response ML</span><span class="named-paragraph-number">1.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1];</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_kind_of_value</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_response</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">response_code_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">R</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    ==&gt; { -, </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cad.html#SP1">&#167;1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2.  </b>Screening for this saves time.
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">CONSTANT_VAL_BITMAP</span><span class="plain-syntax"> (</span><span class="constant-syntax">RULE_MC</span><span class="plain-syntax"> + </span><span class="constant-syntax">RULEBOOK_MC</span><span class="plain-syntax"> + </span><span class="constant-syntax">NAMED_CONSTANT_MC</span><span class="plain-syntax"> + </span><span class="constant-syntax">ACTIVITY_MC</span><span class="plain-syntax"> +</span>
<span class="plain-syntax">    </span><span class="constant-syntax">TABLE_MC</span><span class="plain-syntax"> + </span><span class="constant-syntax">EQUATION_MC</span><span class="plain-syntax"> + </span><span class="constant-syntax">PHRASE_CONSTANT_MC</span><span class="plain-syntax">)</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b>To be a little less vague, the "miscellaneous proper nouns" are: rule
and rulebook names; action names, as nouns; relation names; instances of
kinds; activity names; table names; equation names; and names of phrases
being used as nouns for functional-programming purposes.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-miscellaneous-proper-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">MISCELLANEOUS_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> ((</span><a href="2-rvl.html#SP22" class="function-link"><span class="Preform-function-syntax">Rvalues::is_CONSTANT_of_kind</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">K_action_name</span><span class="Preform-plain-syntax">)) ||</span>
<span class="Preform-plain-syntax">            (</span><a href="2-rvl.html#SP22" class="function-link"><span class="Preform-function-syntax">Rvalues::is_CONSTANT_construction</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">CON_relation</span><span class="Preform-plain-syntax">)) ||</span>
<span class="Preform-plain-syntax">            (</span><a href="2-rvl.html#SP22" class="function-link"><span class="Preform-function-syntax">Rvalues::is_CONSTANT_construction</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">CON_rule</span><span class="Preform-plain-syntax">))) {</span>
<span class="Preform-plain-syntax">            ==&gt; { -, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        }</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">VARIABLE_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">nonlocal_variable</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">nlv</span><span class="Preform-plain-syntax"> = </span><a href="2-lvl.html#SP9" class="function-link"><span class="Preform-function-syntax">Lvalues::get_nonlocal_variable_if_any</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">NonlocalVariables::is_constant</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">nlv</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">            ==&gt; { -, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        }</span>
<span class="Preform-plain-syntax">    }</span>

<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> ((</span><span class="Preform-identifier-syntax">Vocabulary::disjunction_of_flags</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">)) &amp; </span><span class="Preform-constant-syntax">CONSTANT_VAL_BITMAP</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">CONSTANT_VAL_BITMAP</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">            ==&gt; { -, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        }</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4.  </b>Named constants are handled separately.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-named-constant&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">VARIABLE_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">nonlocal_variable</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">nlv</span><span class="Preform-plain-syntax"> = </span><a href="2-lvl.html#SP9" class="function-link"><span class="Preform-function-syntax">Lvalues::get_nonlocal_variable_if_any</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">NonlocalVariables::is_constant</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">nlv</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">            ==&gt; { -, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        }</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5.  </b>There's actually nothing special about rulebook outcome names or use option
names; but because they are stored internally without the compulsory words
"outcome" and "option", they need nonterminals of their own.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-rulebook-outcome-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">MISCELLANEOUS_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><a href="2-rvl.html#SP22" class="function-link"><span class="Preform-function-syntax">Rvalues::is_CONSTANT_of_kind</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">K_rulebook_outcome</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>

<span class="Preform-function-syntax">&lt;s-use-option-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">MISCELLANEOUS_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><a href="2-rvl.html#SP22" class="function-link"><span class="Preform-function-syntax">Rvalues::is_CONSTANT_of_kind</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">K_use_option</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>

<span class="Preform-function-syntax">&lt;s-rule-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">MISCELLANEOUS_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><a href="2-rvl.html#SP22" class="function-link"><span class="Preform-function-syntax">Rvalues::is_CONSTANT_construction</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">CON_rule</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6.  </b>We will also sometimes need a nonterminal which can only produce table
column names, and similarly for property names. These don't fall under
"miscellaneous proper nouns" above, and they aren't in general valid
as constants.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-table-column-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">TABLE_COLUMN_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7.  </b>In order to resolve a subtle distinction of usage later on, we want not
only to parse a property name but also to record whether it was used in
the explicit syntax ("the property open" rather than "open", say).
The internal &lt;s-property-name&gt; uses &lt;property-name-as-noun-phrase&gt;
to do this.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;property-name-as-noun-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;definite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;property-name-construction&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;property-name-construction&gt;</span>

<span class="Preform-function-syntax">&lt;s-property-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">PROPERTY_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-function-syntax">&lt;property-name-as-noun-phrase&gt;</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">))</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-identifier-syntax">Annotations::write_int</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">property_name_used_as_noun_ANNOT</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">else</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-identifier-syntax">Annotations::write_int</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">property_name_used_as_noun_ANNOT</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. Adjective lists. </b>"I first tried to write a story when I was about seven. It was about a dragon.
I remember nothing about it except a philological fact. My mother said nothing
about the dragon, but pointed out that one could not say "a green great dragon",
but had to say "a great green dragon". I wondered why, and still do" (Tolkien
to Auden, 1955). We are going to allow lists of adjectives such as "green great"
or "great green" in any order: although some have suggested conceptual
hierarchies for adjectives (e.g., that size always precedes material) these
are too tendentious to enforce.
</p>

<p class="commentary">The first nonterminal looks quite unnecessary; but it takes the result of
parsing an adjective list and transforms the result to make it a description
(even though there is no actual noun). Inform has to work hard at this sort
of thing, mostly because of deficiencies in English to do with words like
"scenery" and "clothing" which can't be used as count nouns even though,
logically, they should be. Inform implements them adjectivally, but this means
that "scenery" &mdash; an adjective list with one entry &mdash; is sometimes a
description on a par with "door" &mdash; a common noun. In effect, "scenery"
is read as if it were "scenery thing".
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-adjective-list-as-desc&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-adjective-list&gt;</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, SPDesc::add_adjlist(Descriptions::from_proposition(NULL, W), RP[1]) }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9.  </b>So now we test whether an excerpt is a list of adjectives; for example,
this matches
</p>

<blockquote>
    <p>exciting transparent green fixed in place</p>
</blockquote>

<p class="commentary">as a list of four adjectives.
</p>

<p class="commentary">Perhaps surprisingly, the word "not" is allowed in such lists. Since this
looks as if it negates the verb, it ought to belong to the verb phrase, and
surely doesn't belong to the grammar of nouns and their adjectives. But there
are several problems with that analysis. Firstly, English does strange things
with the placing of "not":
</p>

<blockquote>
    <p>The blue door is open and not transparent.</p>
</blockquote>

<blockquote>
    <p>A door is usually not open.</p>
</blockquote>

<p class="commentary">Note that neither of these sentences places "not" adjacent to the verb, so
if we're going to say it's part of the verb phrase then this has to be a
non-contiguous sequence of words able to grab material from possibly distant
NPs. This isn't easy to go along with. Secondly, we also want to provide a
way to write the negation of an adjective. For instance,
</p>

<blockquote>
    <p>exciting not transparent fixed in place</p>
</blockquote>

<p class="commentary">is valid. Though in this case it would be equivalent to write "opaque" in
place of "not transparent", some adjectives do not have named negations.
</p>

<p class="commentary">The grammar for adjective lists also allows the presence of an indefinite
article, less controversially, but that then leads to an interesting and
very arcane de Morgan-law-like point, affecting only a tiny number of
assertion sentences. If we write:
</p>

<blockquote>
    <p>a not great green dragon</p>
</blockquote>

<p class="commentary">Inform considers that "not" applies only to "great"; the dragon is still
to be green. But if we write
</p>

<blockquote>
    <p>not a great green dragon</p>
</blockquote>

<p class="commentary">then Inform requires it to be neither great nor green. It's terrible style
to write this sort of thing as a description outside of a condition like
the following:
</p>

<blockquote>
    <p>if Smaug is not a great green dragon, ...</p>
</blockquote>

<p class="commentary">and conditions like this are parsed with "is not" as the verb and "great
green dragon" as the description, with the adjective list being just "great
green". So this awkward point about "not a..." only comes in when writing
assertion sentences like:
</p>

<blockquote>
    <p>A hairless chimp is not a hairy animal.</p>
</blockquote>

<p class="commentary">(This was submitted as a bug report.) In assertions, Inform has to know for
definite what the truth is, so it can't afford to read this as saying that
the chimp is either not hairy or not an animal.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-adjective-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">not</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;indefinite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-adjective-list-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { 0, SPDesc::make_adjlist(SPDesc::negate_adjlist(RP[2]), W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;indefinite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-adjective-list-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { 0, SPDesc::make_adjlist(RP[2], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-adjective-list-unarticled&gt;</span><span class="Preform-plain-syntax">                             </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { 0, SPDesc::make_adjlist(RP[1], W) }</span>

<span class="Preform-function-syntax">&lt;s-adjective-list-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">not</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-adjective&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                       </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { 0, SPDesc::negate_adjlist(RP[1]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-adjective&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { 0, RP[1] }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">not</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-adjective&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-adjective-list-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { 0, SPDesc::join_adjlist(SPDesc::negate_adjlist(RP[1]), RP[2]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-adjective&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-adjective-list-unarticled&gt;</span><span class="Preform-plain-syntax">               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { 0, SPDesc::join_adjlist(RP[1], RP[2]) }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10.  </b>That reduces us to an internal nonterminal, which matches the longest
possible adjective name it can see.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-adjective&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">?</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve_longest_initial_segment</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">ADJECTIVE_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">a</span><span class="Preform-plain-syntax"> = </span><a href="2-dsc.html#SP1" class="function-link"><span class="Preform-function-syntax">Descriptions::from_proposition</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">NULL</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">unary_predicate</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">ale</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">AdjectivalPredicates::new_up</span><span class="Preform-plain-syntax">(</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-identifier-syntax">RETRIEVE_POINTER_adjective</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Lexicon::get_data</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Node::get_meaning</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">))),</span>
<span class="Preform-plain-syntax">                </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><a href="2-dsc.html#SP8" class="function-link"><span class="Preform-function-syntax">Descriptions::add_to_adjective_list</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">ale</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">a</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">int</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">sc</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Node::get_score</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">sc</span><span class="Preform-plain-syntax"> == </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax">) </span><span class="Preform-identifier-syntax">internal_error</span><span class="Preform-plain-syntax">(</span><span class="Preform-string-syntax">"Length-scored maximal parse with length 0"</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">a</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">Wordings::first_wn</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">) + </span><span class="Preform-identifier-syntax">sc</span><span class="Preform-plain-syntax"> - </span><span class="Preform-constant-syntax">1</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">SPDesc::join_adjlist</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">SPDesc::join_adjlist</span></span>:<br/><a href="4-cad.html#SP9">&#167;9</a>, <a href="4-cad.html#SP12">&#167;12</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">B</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">au</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">au_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_THROUGH_ADJECTIVE_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">au</span><span class="plain-syntax">, </span><span class="identifier-syntax">au_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><a href="2-dsc.html#SP8" class="function-link"><span class="function-syntax">Descriptions::add_to_adjective_list</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">UnaryPredicates::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">au</span><span class="plain-syntax">), </span><span class="identifier-syntax">A</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">A</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">SPDesc::join_adjlist_w</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">SPDesc::join_adjlist_w</span></span>:<br/><a href="4-cad.html#SP12">&#167;12</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">B</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">au</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">au_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_THROUGH_ADJECTIVE_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">au</span><span class="plain-syntax">, </span><span class="identifier-syntax">au_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><a href="2-dsc.html#SP8" class="function-link"><span class="function-syntax">Descriptions::add_to_adjective_list_w</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">UnaryPredicates::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">au</span><span class="plain-syntax">), </span><span class="identifier-syntax">A</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">A</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">SPDesc::make_adjlist</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">SPDesc::make_adjlist</span></span>:<br/><a href="4-cad.html#SP9">&#167;9</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">A</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">SPDesc::negate_adjlist</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">SPDesc::negate_adjlist</span></span>:<br/><a href="4-cad.html#SP9">&#167;9</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">au</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">au_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_THROUGH_ADJECTIVE_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">au</span><span class="plain-syntax">, </span><span class="identifier-syntax">au_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">AdjectivalPredicates::flip_parity</span><span class="plain-syntax">(</span><span class="identifier-syntax">au</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">A</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">SPDesc::add_adjlist</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">SPDesc::add_adjlist</span></span>:<br/><a href="4-cad.html#SP8">&#167;8</a>, <a href="4-cad.html#SP18_3">&#167;18.3</a>, <a href="4-cad.html#SP18_1_1">&#167;18.1.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adjlist</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">adjlist</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><a href="2-rvl.html#SP6" class="function-link"><span class="function-syntax">Rvalues::to_object_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">I</span><span class="plain-syntax">) </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="2-dsc.html#SP5" class="function-link"><span class="function-syntax">Descriptions::from_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><a href="4-cad.html#SP11" class="function-link"><span class="function-syntax">SPDesc::join_adjlist</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">adjlist</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">spec</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">SPDesc::add_adjlist_w</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">SPDesc::add_adjlist_w</span></span>:<br/><a href="4-cad.html#SP18_2">&#167;18.2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adjlist</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">adjlist</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><a href="2-rvl.html#SP6" class="function-link"><span class="function-syntax">Rvalues::to_object_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">I</span><span class="plain-syntax">) </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="2-dsc.html#SP5" class="function-link"><span class="function-syntax">Descriptions::from_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><a href="4-cad.html#SP11" class="function-link"><span class="function-syntax">SPDesc::join_adjlist_w</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">adjlist</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">spec</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13.  </b>And this makes a more semantic check:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">SPDesc::adjlist_applies_to_kind</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">SPDesc::adjlist_applies_to_kind</span></span>:<br/><a href="4-cad.html#SP17_1">&#167;17.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">au</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">au_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_THROUGH_ADJECTIVE_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">au</span><span class="plain-syntax">, </span><span class="identifier-syntax">au_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">aph</span><span class="plain-syntax"> = </span><span class="identifier-syntax">AdjectivalPredicates::to_adjective</span><span class="plain-syntax">(</span><span class="identifier-syntax">au</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">AdjectiveAmbiguity::can_be_applied_to</span><span class="plain-syntax">(</span><span class="identifier-syntax">aph</span><span class="plain-syntax">, </span><span class="identifier-syntax">K</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14.  </b>The following global is needed only to pass a parameter from one Preform token
to another one parsed immediately after it has been matched; it has no
significance the rest of the time.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">s_adj_domain</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15.  </b>This prevents doubled issue of the same problem message.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">PM_DefiniteCommonNoun_issued_at</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">PM_SpecificCalling_issued_at</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">PM_PastSubordinate_issued_at</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16.  </b>When they appear in descriptions, these adjectives serve as "qualifiers":
they qualify their nouns. For example, "open door" consists of "open",
a qualifier, followed by "door", a noun.
</p>

<p class="commentary">Not every value known to Inform can be qualified as a noun: in fact, very few
can be. This prevents us from writing "even 3", that is, the number 3 as
a noun qualified by the adjective "even"; doctrinally, Inform takes the
line that adjectives applied to values like 3 will never vary in their
applicability &mdash; 3 is always odd &mdash; so that it makes no sense to test for
them with conditions like
</p>

<blockquote>
    <p>if N is an even 3, ...</p>
</blockquote>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-qualifiable-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;k-kind&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Specifications::from_kind(RP[1]) }; s_adj_domain = RP[1];</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-object-instance&gt;</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, RP[1] }; s_adj_domain = NULL;</span>

<span class="Preform-function-syntax">&lt;s-qualifiable-common-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;k-kind&gt;</span><span class="Preform-plain-syntax">             </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Specifications::from_kind(RP[1]) }; s_adj_domain = RP[1];</span>

<span class="Preform-function-syntax">&lt;s-qualifiable-proper-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-object-instance&gt;</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, RP[1] }; s_adj_domain = NULL;</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17.  </b>The following is used only in combination with a qualifiable noun: it
simply provides a filter on &lt;s-adjective-list&gt; to require that each
adjective listed must be one which applies to the noun. For example,
"empty room" won't be parsed as "empty" qualifying "room" because
(perhaps curiously) the Standard Rules don't define "empty" for rooms;
whereas "empty rulebook" will work.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-applicable-adjective-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-adjective-list&gt;</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, RP[1] }; </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP17_1" class="named-paragraph-link"><span class="named-paragraph">Require adjective to be applicable</span><span class="named-paragraph-number">17.1</span></a></span><span class="Preform-constant-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP17_1" class="paragraph-anchor"></a><b>&#167;17.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Require adjective to be applicable</span><span class="named-paragraph-number">17.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">s_adj_domain</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><a href="4-cad.html#SP13" class="function-link"><span class="function-syntax">SPDesc::adjlist_applies_to_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">s_adj_domain</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cad.html#SP17">&#167;17</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP18" class="paragraph-anchor"></a><b>&#167;18. Descriptions. </b>Grammatically, a description is a sequence of the following five elements, some
of which are optional:
</p>

<ul class="items"><li>(a) specifier, which will be a determiner and/or an article (optional);
</li><li>(b) qualifier, which for Inform means adjectives of the various kinds
described above (optional);
</li><li>(c) qualifiable noun (sometimes optional, sometimes compulsory); and
</li><li>(d) subordinate clause, such as "in ..." or "which are on ..."
(optional).
</li></ul>
<p class="commentary">For the most part the sequence must be (a), (b), (c), (d), as in:
</p>

<blockquote>
    <p>six of the / open / containers / in the Attic</p>
</blockquote>

<p class="commentary">but the composite words made up from quantifiers and kinds &mdash; something,
anywhere, everybody, and such &mdash; force us to make an exception to this:
</p>

<blockquote>
    <p>something / open / in the Attic</p>
</blockquote>

<p class="commentary">which takes the sequence (a) and (c), (b), (d). We will call words like
"something" and "everywhere" specifying nouns, since they are both
noun and specifier in one.
</p>

<p class="commentary">Simpler readings beat more complicated ones. Thus we won't match a
subordinate clause if there's a way to read the text which doesn't need to;
and similarly for specifiers.
</p>

<p class="commentary">In cases of ambiguity, the earliest split wins: that is, the one
maximising the length of the noun. This means that if the source text
actually created something called "dark room", then the text "dark room"
will not be confused with "dark (i.e., the property) room (i.e, the kind)",
since that splits later.
</p>

<p class="commentary">In the grammar for &lt;s-description&gt;, the noun is compulsory.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-description&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-desc-uncomposite-inner&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                              </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-np-with-relative-clause&gt;</span><span class="Preform-plain-syntax">                               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-desc-uncomposite&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-desc-uncomposite-inner&gt;</span><span class="Preform-plain-syntax">                                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-desc-uncomposite-inner&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-desc-uncalled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">(</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">called</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-calling-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">)</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_4" class="named-paragraph-link"><span class="named-paragraph">Glue on the calling ML</span><span class="named-paragraph-number">18.4</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-desc-uncalled&gt;</span><span class="Preform-plain-syntax">                                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-desc-uncalled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-specifier&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-desc-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_5" class="named-paragraph-link"><span class="named-paragraph">Glue on the quantification ML</span><span class="named-paragraph-number">18.5</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-specifying-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                     </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-specifying-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-adjective-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_2" class="named-paragraph-link"><span class="named-paragraph">Glue on trailing adjectives</span><span class="named-paragraph-number">18.2</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-can-omit-trying&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;definite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-common-desc-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 3 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">^&lt;if-can-omit-trying&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">^&lt;if-multiplicitous&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;definite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-common-desc-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_6" class="named-paragraph-link"><span class="named-paragraph">Issue PM_DefiniteCommonNoun problem</span><span class="named-paragraph-number">18.6</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;definite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-proper-desc-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 2 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;indefinite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-desc-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 2 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-desc-unspecified&gt;</span><span class="Preform-plain-syntax">                                      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-desc-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-qualifiable-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-applicable-adjective-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-qualifiable-noun&gt;</span><span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_3" class="named-paragraph-link"><span class="named-paragraph">Glue on leading adjectives</span><span class="named-paragraph-number">18.3</span></a></span>

<span class="Preform-function-syntax">&lt;s-common-desc-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-qualifiable-common-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                             </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-applicable-adjective-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-qualifiable-common-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_3" class="named-paragraph-link"><span class="named-paragraph">Glue on leading adjectives</span><span class="named-paragraph-number">18.3</span></a></span>

<span class="Preform-function-syntax">&lt;s-proper-desc-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-qualifiable-proper-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                             </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-applicable-adjective-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-qualifiable-proper-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_3" class="named-paragraph-link"><span class="named-paragraph">Glue on leading adjectives</span><span class="named-paragraph-number">18.3</span></a></span>

<span class="Preform-function-syntax">&lt;if-multiplicitous&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;-&gt;</span><span class="Preform-identifier-syntax">multiplicitous</span><span class="Preform-plain-syntax">) </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP18_1" class="paragraph-anchor"></a><b>&#167;18.1.  </b>The grammar for &lt;s-desc-nounless&gt; is almost exactly the same
except that the noun is optional. The only difference is right at the bottom.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-desc-nounless&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-desc-nounless-uncomposite&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-np-with-relative-clause&gt;</span><span class="Preform-plain-syntax">                               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-desc-nounless-uncomposite&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-desc-nounless-uncalled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">(</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">called</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-calling-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">)</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_4" class="named-paragraph-link"><span class="named-paragraph">Glue on the calling ML</span><span class="named-paragraph-number">18.4</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-desc-nounless-uncalled&gt;</span><span class="Preform-plain-syntax">                                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-desc-nounless-uncalled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-specifier&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-desc-nounless-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">             </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_5" class="named-paragraph-link"><span class="named-paragraph">Glue on the quantification ML</span><span class="named-paragraph-number">18.5</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-specifying-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                     </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-specifying-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-adjective-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_2" class="named-paragraph-link"><span class="named-paragraph">Glue on trailing adjectives</span><span class="named-paragraph-number">18.2</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-can-omit-trying&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;definite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-common-desc-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 3 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">^&lt;if-can-omit-trying&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">^&lt;if-multiplicitous&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;definite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-common-desc-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_6" class="named-paragraph-link"><span class="named-paragraph">Issue PM_DefiniteCommonNoun problem</span><span class="named-paragraph-number">18.6</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;indefinite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-desc-nounless-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 2 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;definite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-proper-desc-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 2 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-desc-nounless-unspecified&gt;</span><span class="Preform-plain-syntax">                             </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-desc-nounless-unspecified&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-qualifiable-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-applicable-adjective-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-qualifiable-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_3" class="named-paragraph-link"><span class="named-paragraph">Glue on leading adjectives</span><span class="named-paragraph-number">18.3</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-adjective-list&gt;</span><span class="Preform-plain-syntax">                                        </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cad.html#SP18_1_1" class="named-paragraph-link"><span class="named-paragraph">Describe with adjectives alone</span><span class="named-paragraph-number">18.1.1</span></a></span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP18_2" class="paragraph-anchor"></a><b>&#167;18.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Glue on trailing adjectives</span><span class="named-paragraph-number">18.2</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    ==&gt; { -, </span><a href="4-cad.html#SP12" class="function-link"><span class="function-syntax">SPDesc::add_adjlist_w</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cad.html#SP18">&#167;18</a>, <a href="4-cad.html#SP18_1">&#167;18.1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP18_3" class="paragraph-anchor"></a><b>&#167;18.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Glue on leading adjectives</span><span class="named-paragraph-number">18.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    ==&gt; { -, </span><a href="4-cad.html#SP12" class="function-link"><span class="function-syntax">SPDesc::add_adjlist</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cad.html#SP18">&#167;18</a> (three times), <a href="4-cad.html#SP18_1">&#167;18.1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP18_1_1" class="paragraph-anchor"></a><b>&#167;18.1.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Describe with adjectives alone</span><span class="named-paragraph-number">18.1.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    ==&gt; { -, </span><a href="4-cad.html#SP12" class="function-link"><span class="function-syntax">SPDesc::add_adjlist</span></a><span class="plain-syntax">(</span><a href="2-dsc.html#SP1" class="function-link"><span class="function-syntax">Descriptions::from_proposition</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">), </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cad.html#SP18_1">&#167;18.1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP18_4" class="paragraph-anchor"></a><b>&#167;18.4.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Glue on the calling ML</span><span class="named-paragraph-number">18.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1];</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">c</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2];</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">CONSTANT_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">PM_SpecificCalling_issued_at</span><span class="plain-syntax"> != </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">PM_SpecificCalling_issued_at</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_SpecificCalling</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"a 'called' name can only be given to something "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"which is described vaguely"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"and can't be given to a definite object or value. "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"So 'if a thing (called the gadget) is carried' is "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"allowed, but 'if the X-Ray Zapper (called the gadget) "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"is carried' isn't allowed - if it's the X-Ray Zapper, "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"then call it that."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="2-spc.html#SP3" class="function-link"><span class="function-syntax">Specifications::is_description</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Frames::current_stack_frame</span><span class="plain-syntax">()) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">C</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">c</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><a href="2-dsc.html#SP10" class="function-link"><span class="function-syntax">Descriptions::attach_calling</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">C</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><a href="2-spc.html#SP1" class="function-link"><span class="function-syntax">Specifications::to_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">LocalVariables::ensure_calling</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">, </span><span class="identifier-syntax">K</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        ==&gt; { </span><span class="identifier-syntax">fail</span><span class="plain-syntax"> };</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    ==&gt; { -, </span><span class="identifier-syntax">p</span><span class="plain-syntax"> };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cad.html#SP18">&#167;18</a>, <a href="4-cad.html#SP18_1">&#167;18.1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP18_5" class="paragraph-anchor"></a><b>&#167;18.5.  </b>Determiners make sense in the context of a common noun, e.g., "three doors",
but not usually for proper nouns ("all 5"). But we allow existence in the
context of a proper noun, as in "some tea", because it may be confusion of
"some" the determiner with "some" the indefinite article.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Glue on the quantification ML</span><span class="named-paragraph-number">18.5</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2];</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">annotation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1];</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">quant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_quant</span><span class="plain-syntax">(</span><span class="identifier-syntax">annotation</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">quant</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="2-spc.html#SP3" class="function-link"><span class="function-syntax">Specifications::is_description</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><a href="2-dsc.html#SP9" class="function-link"><span class="function-syntax">Descriptions::quantify</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">quant</span><span class="plain-syntax">, </span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">annotation</span><span class="plain-syntax">, </span><span class="identifier-syntax">quantification_parameter_ANNOT</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (!((</span><span class="identifier-syntax">quant</span><span class="plain-syntax"> == </span><span class="identifier-syntax">exists_quantifier</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">CONSTANT_NT</span><span class="plain-syntax">)))) {</span>
<span class="plain-syntax">            ==&gt; { </span><span class="identifier-syntax">fail</span><span class="plain-syntax"> };</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    ==&gt; { -, </span><span class="identifier-syntax">p</span><span class="plain-syntax"> };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cad.html#SP18">&#167;18</a>, <a href="4-cad.html#SP18_1">&#167;18.1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP18_6" class="paragraph-anchor"></a><b>&#167;18.6.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue PM_DefiniteCommonNoun problem</span><span class="named-paragraph-number">18.6</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">PM_DefiniteCommonNoun_issued_at</span><span class="plain-syntax"> != </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">) ||</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">PM_DefiniteCommonNoun_issued_at</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PM_DefiniteCommonNoun_issued_at</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::quote_source</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::quote_wording</span><span class="plain-syntax">(2, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_DefiniteCommonNoun</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">            </span><span class="string-syntax">"In %1, I'm not able to understand what specific thing is meant "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"by the phrase '%2'. You use the definite article 'the', which "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"suggests you have a particular thing in mind, but then you go "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"on to refer to a kind rather than something definite. Quite "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"likely a human reading this sentence would find it obvious what "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"you mean, but I don't. %P"</span>
<span class="plain-syntax">            </span><span class="string-syntax">"This often arises when writing something like: 'Instead of "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"opening a door when the door is closed' - where clearly a human "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"would understand that 'the door' refers to the same one in 'a "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"door' earlier. I can make sense of this only if you help: for "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"example, 'Instead of opening a door (called the portal) when "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"the portal is closed' would work. So would 'Instead of opening "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"a closed door'; or 'Instead of opening a door which is closed'. "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"All of these alternatives help me by making clear that only one "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"door is being talked about."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    ==&gt; { -, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[4] };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cad.html#SP18">&#167;18</a>, <a href="4-cad.html#SP18_1">&#167;18.1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP19" class="paragraph-anchor"></a><b>&#167;19.  </b>This simply wraps up a calling name into S-grammar form.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-calling-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Node::new_with_words(UNKNOWN_NT, WR[1]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax">              </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Node::new_with_words(UNKNOWN_NT, WR[1]) }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP20" class="paragraph-anchor"></a><b>&#167;20.  </b>The following is written as an internal, voracious nonterminal for speed.
It matches text like "all", "six of the" and "most".
</p>

<p class="commentary">Note that an article can follow a determiner, as in "six of the people", where
"six of" is a determiner. At this point we don't need to notice whether the
article is definite or not, and we're similarly turning a blind eye to singular
vs plural.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-specifier&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">?</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">int</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">which_N</span><span class="Preform-plain-syntax"> = -1; </span><span class="Preform-identifier-syntax">quantifier</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">quantifier_used</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">NULL</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">int</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">x1</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Quantifiers::parse_against_text</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">, &amp;</span><span class="Preform-identifier-syntax">which_N</span><span class="Preform-plain-syntax">, &amp;</span><span class="Preform-identifier-syntax">quantifier_used</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">x1</span><span class="Preform-plain-syntax"> &gt;= </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> ((</span><span class="Preform-identifier-syntax">x1</span><span class="Preform-plain-syntax">&lt;</span><span class="Preform-identifier-syntax">Wordings::last_wn</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">)) &amp;&amp; (</span><span class="Preform-identifier-syntax">NTI::test_word</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">x1</span><span class="Preform-plain-syntax">, </span><span class="Preform-function-syntax">&lt;article&gt;</span><span class="Preform-plain-syntax">))) </span><span class="Preform-identifier-syntax">x1</span><span class="Preform-plain-syntax">++;</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">qp</span><span class="Preform-plain-syntax"> = </span><a href="2-spc.html#SP11" class="function-link"><span class="Preform-function-syntax">Specifications::new_UNKNOWN</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Wordings::up_to</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">x1</span><span class="Preform-plain-syntax">-1));</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">Node::set_quant</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">qp</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">quantifier_used</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">Annotations::write_int</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">qp</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">quantification_parameter_ANNOT</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">which_N</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">qp</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">x1</span><span class="Preform-plain-syntax">-1;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP21" class="paragraph-anchor"></a><b>&#167;21.  </b>Similarly, this nonterminal matches specifying nouns like "somebody" or
"everywhere". Doctrinally, "something" is not taken to refer explicitly
to the kind "thing", whereas "somebody" does refer to people and
"everywhere" to places: English is slippery on this.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-specifying-noun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">?</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">wording</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">DW</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Wordings::first_word</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">quantifier</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">quantifier_used</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">NULL</span><span class="Preform-plain-syntax">; </span><span class="Preform-identifier-syntax">kind</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">some_kind</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">NULL</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">PluginCalls::parse_composite_NQs</span><span class="Preform-plain-syntax">(&amp;</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">, &amp;</span><span class="Preform-identifier-syntax">DW</span><span class="Preform-plain-syntax">, &amp;</span><span class="Preform-identifier-syntax">quantifier_used</span><span class="Preform-plain-syntax">, &amp;</span><span class="Preform-identifier-syntax">some_kind</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">some_kind</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><a href="2-dsc.html#SP3" class="function-link"><span class="Preform-function-syntax">Descriptions::from_kind</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">some_kind</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">quantifier_used</span><span class="Preform-plain-syntax">) </span><a href="2-dsc.html#SP9" class="function-link"><span class="Preform-function-syntax">Descriptions::quantify</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">quantifier_used</span><span class="Preform-plain-syntax">, -1);</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">Wordings::first_wn</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">) - </span><span class="Preform-constant-syntax">1</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="4-ets.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-vm.html">1</a></li><li class="progresschapter"><a href="2-spc.html">2</a></li><li class="progresschapter"><a href="3-pl.html">3</a></li><li class="progresscurrentchapter">4</li><li class="progresssection"><a href="4-ets.html">ets</a></li><li class="progresscurrent">cad</li><li class="progresssection"><a href="4-teav.html">teav</a></li><li class="progresssection"><a href="4-varc.html">varc</a></li><li class="progresssection"><a href="4-cap.html">cap</a></li><li class="progresssection"><a href="4-il.html">il</a></li><li class="progresssection"><a href="4-inv.html">inv</a></li><li class="progresssection"><a href="4-pi.html">pi</a></li><li class="progresschapter"><a href="5-dsh.html">5</a></li><li class="progressnext"><a href="4-teav.html">&#10095;</a></li></ul></div>
</nav><!-- End of weave -->

		</main>
	</body>
</html>

